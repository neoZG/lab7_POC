# POC Edge-Content Offline-First

Este repositorio contiene una prueba de concepto (POC) de un sistema **offline-first** de entrega de contenido (PDF/VÃ­deos) usando un servidor central y un servidor edge (cache local), todo simulado en Python.

---

## ğŸ“‚ Estructura de carpetas y archivos

```bash
your-project/
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ ci.yml             # ConfiguraciÃ³n de GitHub Actions
â”œâ”€â”€ data.py                    # Datos mock: usuarios, contenidos, chunks, cache
â”œâ”€â”€ cache.py                   # LÃ³gica de gestiÃ³n de cache (evicciÃ³n)
â”œâ”€â”€ app.py                     # AplicaciÃ³n Flask con endpoints REST
â”œâ”€â”€ requirements.txt           # Dependencias Python
â””â”€â”€ tests/                     # Suite de pruebas pytest
    â”œâ”€â”€ conftest.py            # Fixture de cliente Flask
    â”œâ”€â”€ test_offline.py        # Test de acceso offline
    â”œâ”€â”€ test_bandwidth.py      # Test de descarga en chunks + compresiÃ³n
    â”œâ”€â”€ test_storage.py        # Test de lÃ­mites de almacenamiento
    â””â”€â”€ test_reliability.py    # Test de reintento y reanudaciÃ³n
```

---

## ğŸš€ InstalaciÃ³n y ejecuciÃ³n local

1. Clonar el repositorio y entrar en la carpeta del proyecto:

   ```bash
   git clone <url-repo>
   cd your-project
   ```

2. Crear y activar un entorno virtual:

   ```bash
   python3 -m venv venv
   source venv/bin/activate
   ```

3. Instalar dependencias:

   ```bash
   pip install --upgrade pip
   pip install -r requirements.txt
   ```

4. Iniciar la aplicaciÃ³n Flask:

   ```bash
   export FLASK_APP=app.py
   flask run
   ```

   La API quedarÃ¡ disponible en `http://127.0.0.1:5000`.

5. En otro terminal (o en background) ejecutar los tests:

   ```bash
   pytest
   ```

---

## ğŸ“¡ Endpoints disponibles

| MÃ©todo | Ruta             | DescripciÃ³n                                                   |
| ------ | ---------------- | ------------------------------------------------------------- |
| POST   | `/login`         | Autentica usuario y guarda token en cache local para offline. |
| GET    | `/content`       | Listado de contenidos disponibles (metadatos).                |
| GET    | `/download/<id>` | Descarga un contenido en chunks comprimidos, guarda en cache. |
| POST   | `/sync-chunk`    | Simula subida de un chunk modificado al servidor (colas).     |
| POST   | `/auth/sync`     | Sincroniza cambios de credenciales (stub en POC).             |

---

## ğŸ“¦ SimulaciÃ³n de componentes

* **Usuarios (`data.py`)**: Diccionario con user/password y token JWT.
* **Content DB**: Metadatos de archivos (`size`, `chunks`).
* **Chunks Store**: Lista de bytes por archivo, simula troceo.
* **Cache**: Almacenamiento local por usuario, con lÃ­mite de 10â€¯GB y polÃ­ticas de evicciÃ³n.
* **Message Queue**: Lista en memoria para simular colas BMQ.

---

## ğŸ› ï¸ Funciones de fitness (tests automatizados)

1. **Acceso offline** (`test_offline.py`): Verifica login y lectura desde cache sin red.
2. **OptimizaciÃ³n de ancho de banda** (`test_bandwidth.py`): Descarga en chunks + "compresiÃ³n" (reducciÃ³n de tamaÃ±o).
3. **LÃ­mites de almacenamiento** (`test_storage.py`): EvicciÃ³n de archivos cuando se supera 10â€¯GB.
4. **Confiabilidad** (`test_reliability.py`): Simula caÃ­das aleatorias y reintentos por chunk.

Cada test estÃ¡ implementado con **pytest** y ejerce la lÃ³gica que debe validar cada fitness function.

---

## âœ… IntegraciÃ³n continua con GitHub Actions

El archivo `.github/workflows/ci.yml` define un workflow que:

1. Se dispara en `push` o `pull_request`.
2. Instala Python 3.9 y dependencias.
3. Inicia la app Flask en background.
4. Espera 2 segundos para arranque.
5. Ejecuta `pytest`.

Si todos los tests pasan, la acciÃ³n finaliza con Ã©xito.
